# -*- coding: utf-8 -*-
"""hands_on_eduardo_guimaraes.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AyCsptS9IKSvqJ-MUnhWrwlcFgrwlXPi

#Hands-on #01 / #02 - Eduardo Guimar√£es

This activity will address air routes.
In the selected graph, nodes represent US airports and edges represents routes between them.

As there were some impurities in the first two lines of the file, as well as the absence of brackets at the end of each line, which were preventing the library from creating the graph, a processing was performed on the original file, and from it, the file 'arquivo_limpo.txt' was created
"""

import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
import matplotlib as mpl
import scipy.io
import collections

# Path to MTX file
mtx_file_path = './inf-USAir97.mtx'

# Read MTX file
mtx_data = scipy.io.mmread(mtx_file_path)
grafo = nx.DiGraph(mtx_data)
nx.draw(grafo, with_labels=True)
plt.show()

print("Number of airports: {0}".format(len(grafo)))
print("Total amount of routes: {0}".format(grafo.size()))

print("Is there a route between airport 7 and 3? {0}".format(grafo.has_edge(7,3)))

print("List of airports: {0}".format(grafo.nodes(data=False)))
print("Airports with a route to airport 5: {0}".format(list(grafo.neighbors(5))))

graus = [grafo.degree(node) for node in grafo]
kmin = min(graus)
kmax = max(graus)
print("Average routes between airports: {0}".format(np.average(graus)))

"""#Drawing:"""

# using the force-based or "spring" layout algorithm
fig = plt.figure(figsize=(8,8))
nx.draw_spring(grafo, node_size=20)

"""Some airports are completly isolated!!"""

# using the fcircular layout algorithm
fig = plt.figure(figsize=(8,8))
nx.draw_circular(grafo, node_size=40)

"""The comprehension is not that easy in this case =/"""

nx.draw(grafo)

nx.draw_kamada_kawai(grafo , node_size=40)

nx.draw_networkx_edges(grafo , pos=nx.spring_layout(grafo), edge_color='red', width=2)

# Get 10 logarithmically spaced bins between kmin and kmax
bin_edges = np.logspace(np.log10(kmin), np.log10(kmax), num=10)

# histogram the data into these bins
density, _ = np.histogram(graus, bins=bin_edges, density=True)

fig = plt.figure(figsize=(6,4))

# "x" should be midpoint (IN LOG SPACE) of each bin
log_be = np.log10(bin_edges)
x = 10**((log_be[1:] + log_be[:-1])/2)

plt.plot(x, density, marker='o', linestyle='none')
plt.xlabel(r"degree $k$", fontsize=16)
plt.ylabel(r"$P(k)$", fontsize=16)

# remove right and top boundaries because they're ugly
ax = plt.gca()
ax.spines['right'].set_visible(False)
ax.spines['top'].set_visible(False)
ax.yaxis.set_ticks_position('left')
ax.xaxis.set_ticks_position('bottom')

# Show the plot
plt.show()

"""#Summarization of the Graph (degree distribution):

"""

# Calculate degree distribution
degree_sequence = sorted([d for n, d in grafo.degree()], reverse=True)  # List of degrees of all nodes
degree_count = nx.degree_histogram(grafo)  # Count of nodes with each degree
degrees = range(len(degree_count))  # Range of degrees

# Plot degree distribution
plt.bar(degrees, degree_count, width=0.8, color='b')
plt.title("Degree Distribution")
plt.ylabel("Count")
plt.xlabel("Degree")
plt.show()

"""# Largest Component Size
That's the airport with the largest amount of connections
"""

print("Largest Component Size: {0}".format(kmax))

"""# Distance Distribution:
In this case, refers to how many places I can go with a direct flight, a flight with one connection, a flight with 2 connections and so on
"""

# Calculating shortest path lengths
shortest_paths = dict(nx.shortest_path_length(grafo))

# Computing distance distribution
distance_counts = {}
for source in shortest_paths:
    for target, distance in shortest_paths[source].items():
        if distance in distance_counts:
            distance_counts[distance] += 1
        else:
            distance_counts[distance] = 1

# Drawing
distances = list(distance_counts.keys())
counts = list(distance_counts.values())

plt.bar(distances, counts, width=0.5, color='b')
plt.xlabel('Distance')
plt.ylabel('Count')
plt.title('Distance Distribution in the Graph')
plt.grid(True)
plt.show()

"""# Clustering Coefficient:"""

def general_clustering_coefficient(G):
    clustering_coefficients = {}

    for node in G.nodes():
        successors = set(G.successors(node))
        predecessors = set(G.predecessors(node))

        if len(successors) + len(predecessors) < 2:
            clustering_coefficients[node] = 0.0
        else:
            possible_edges = len(successors) * len(predecessors)
            actual_edges = 0

            for successor in successors:
                for predecessor in predecessors:
                    if G.has_edge(predecessor, successor):
                        actual_edges += 1

            clustering_coefficients[node] = actual_edges / possible_edges

    return clustering_coefficients

    # Calculate general clustering coefficients
    coeffs = general_clustering_coefficient(grafo)

    # Print the results
    print("General Clustering Coefficient")
    for node, coeff in coeffs.items():
        print(f"{node}\t{coeff:.4f}")

"""# Betweenness Centrality
It's the measure of the centrality of a given node. In other words, it's the number of times a node acts as a bridge between two nodes in a shortest path context.
"""

# There's an embedded function for calculating the betweenness centrality
betweenness_dict = nx.betweenness_centrality(grafo)

# Printing the betweenness centrality for each node
for node, centrality in sorted(betweenness_dict.items()):
    print(f"Node {node}: {centrality:.4f}")

"""# A Brief Discussion
Graphs metrics can seem a little complex or too abstract at a first sight.

However, when applying them for a real-world scenario, it becomes not only easier to undestand them but also sheds a light on why they are so important and so widely studied.

Those metrics provide very valuable information and, at the end of the day, it's what consist their intrinsec value. Great value, by the way.

On the airport network, for example, we can have an idea on how many airports directly connect to other airports (Degree Distribution), providing a valuable information about the connectivity of these places, which is crucial for a efficient logisctic service.

The Distance Distribution can shed a light on how many trips options there are for each number of different connections. And also provides a information about how integrated the system is (the greater the number of direct flights is, the greater the system is connected and well integrated). "Number of Shortest Path = 1" is a nice target to aim in this context.

Clustering Coefficient can indicate well-integrated areas.

And the Betweenness Centrality can provide the information on how much is a given airport a bridge between others. This information is crucial for designing and enhancing the airport architecture and planning the flow of travelers to make their experience and efficiency as good as possible.
"""
